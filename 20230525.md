# 5월 25일

## 처음부터..

### 이미지 띄우기
```python
mport cv2

img_file = "../img/girl.jpg" # 표시할 이미지 경로           
img = cv2.imread(img_file)  # 이미지를 읽어서 img 변수에 할당

if img is not None:
  cv2.imshow('IMG', img)   # 읽은 이미지를 화면에 표시     
  cv2.waitKey()           # 키가 입력될 때 까지 대기   
  cv2.destroyAllWindows()  # 창 모두 닫기         
else:
    print('No image file.')
```
- 저장된 이미지를 'imread'를 통해 불러와서 'imshow'로 화면에 띄움

> 실행 결과

![Screenshot from 2023-05-25 10-39-13](https://github.com/ajhwan/OpenCV_study/assets/129160008/6192bac2-7e24-43ac-9f48-ad9398ea738c)

### 이미지 스케일 바꾸기
```python
import cv2

img_file = "../img/girl.jpg" 
save_file = "../img/girl_gray.jpg"
img = cv2.imread(img_file, cv2.IMREAD_GRAYSCALE)  #그레이 스케일로 읽기

if img is not None:
    cv2.imshow('IMG', img)
    cv2.imwrite(save_file, img)
    cv2.waitKey()
    cv2.destroyAllWindows()
else:
    print('No image file.')
    
````
- 앞선 코드에서 저장할 공간을 만들고, 'cv2.IMREAD_GRAYSCALE'을 통해 그레이 스케일로 읽어옴
- 이후 'imwrite'로 이미지를 읽음

> 실행 결과

![Screenshot from 2023-05-25 10-41-23](https://github.com/ajhwan/OpenCV_study/assets/129160008/39ab0d2f-4dca-416f-a4af-ca3d21b633c8)

### 동영상 파일 읽기
```python
import cv2

video_file = "../img/big_buck.avi" # 동영상 파일 경로

cap = cv2.VideoCapture(video_file) # 동영상 캡쳐 객체 생성 
if cap.isOpened():                 # 캡쳐 객체 초기화 확인
    while True:
        ret, img = cap.read()      # 다음 프레임 읽기  
        if ret:                     # 프레임 읽기 정상
            cv2.imshow(video_file, img) # 화면에 표시 
            cv2.waitKey(25)            # 25ms 지연(40fps로 가정)  
        else:                       # 다음 프레임 읽을 수 없으면
            break                   # 재생 완료
else:
    print("can't open video.")      # 캡쳐 객체 초기화 실패
cap.release()                       # 캡쳐 자원 반납
cv2.destroyAllWindows()
```
- '.avi'파일로 된 동영상 파일을 읽어와서 'cv2.VideoCapture'로 동영상 캡쳐 객체를 생성하여 동영상을 첫 프레임을 읽음
- 'cap.read()'를 통해 동영상을 다음 프레임을 읽고 정상적으로 읽혀졌다면 'while'문의 'imshow'를 통해 화면에 연속적으로 화면에 표시
- 더이상 읽을 프레임이 없다면(다음 프레임이 없다면) 'break'를 통해 탈출(재생 완료)
- 'cap.release()'로 객체 자원을 반납

> 실행 결과

![Screenshot from 2023-05-25 10-50-43](https://github.com/ajhwan/OpenCV_study/assets/129160008/59d27cfe-20fd-40b1-b3f1-d2d2f1b6b347)
![Screenshot from 2023-05-25 10-50-28](https://github.com/ajhwan/OpenCV_study/assets/129160008/322c6d54-e6aa-4153-8bef-08c62b0989da)

### 웹캠 프레임 읽기

```python
import cv2

cap = cv2.VideoCapture(0)               # 0번 카메라 장치 연결
if cap.isOpened():                      # 캡쳐 객체 연결 확인
    while True:
        ret, img = cap.read()           # 다음 프레임 읽기
        if ret:
            cv2.imshow('camera', img)   # 다음 프레임 이미지 표시
            if cv2.waitKey(1) != -1:    # 1ms 동안 키 입력 대기
                break                   # 아무 키라도 입력이 있으면 중지
        else:
            print('no frame')
            break
else:
    print("can't open camera.")
cap.release()                           # 자원 반납
cv2.destroyAllWindows()
```
- 'cv2.VideoCapture(0)'를 통해 0번 카메라 장치에 웹캠을 연결 후 'cap.isOpened()'로 연결을 확인
- 'cap.read()'로 다음 프레임을 읽고, 'imshow'를 통해 다음 프레임을 표시해줌
- 'cv2.waitKey(1) != -1'을 통해 키보드의 입력이 있으면 중
> 실행 결과

![Screenshot from 2023-05-25 10-56-05](https://github.com/ajhwan/OpenCV_study/assets/129160008/1c0fc1ee-20bf-463c-916a-1f38422d0b40)

### 웹캠으로 사진 찍기

```python
import cv2

cap = cv2.VideoCapture(0)                       # 0번 카메라 연결

# cap.set(cv2.CAP_PROP_FRAME_WIDTH, 100)
# cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 30)

if cap.isOpened() :
    while True:
        ret, frame = cap.read()                 # 카메라 프레임 읽기
        if ret:
            cv2.imshow('camera',frame)          # 프레임 화면에 표시
            if cv2.waitKey(1) != -1:            # 아무 키나 누르면
                cv2.imwrite('photo.jpg', frame) # 프레임을 'photo.jpg'에 저장
                break
        else:
            print('no frame!')
            break
else:
    print('no camera!')
cap.release()
cv2.destroyAllWindows()
```
- 앞선 코드에서 입력키를 누르면 'imwrite'를 통해 이미지를 저장하고 종료시킴
> 실행 결과

![photo](https://github.com/ajhwan/OpenCV_study/assets/129160008/a45af489-84b1-49b0-b257-704f4bcf5345)

### 웹갬으로 동영상 촬영하기
```python
import cv2

cap = cv2.VideoCapture(0)    # 0번 카메라 연결
if cap.isOpened:
    file_path = './record.avi'    # 저장할 파일 경로 이름
    fps = 30.0                     # FPS, 초당 프레임 수
    fourcc = cv2.VideoWriter_fourcc(*'DIVX') # 인코딩 포맷 문자
    width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)
    height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
    size = (int(width), int(height))                        # 프레임 크기
    out = cv2.VideoWriter(file_path, fourcc, fps, size) # VideoWriter 객체 생성
    while True:
        ret, frame = cap.read()
        if ret:
            cv2.imshow('camera-recording',frame)
            out.write(frame)                        # 파일 저장
            if cv2.waitKey(int(1000/fps)) != -1: 
                break
        else:
            print("no frame!")
            break
    out.release()                                   # 파일 닫기
else:
    print("can't open camera!")
cap.release()
cv2.destroyAllWindows()
```
- 'cv2.VideoWriter'를 사용하면 여러 프레임을 동영상으로 저장할 수 있음
- cv2.VideoWriter(file_path, fourcc, fps, (width, height))
  - file_path : 동영상 파일을 저장할 경로 
  - fourcc : 동영상 인코딩 형식(codec 정보)
  - fps : 초당 저장될 프레임 수 
  - (width, height) : 프레임의 너비와 높이
- 코드 실행과 동시에 녹화가 시작되고, 앞선 코드와 마찬가지로 키보드의 입력이 있을 때까지 촬영 및 저장 후 종료됨
> 실행 결과

https://github.com/ajhwan/OpenCV_study/assets/129160008/fed118d9-b41b-4935-ad43-6f61a12d0f8d



