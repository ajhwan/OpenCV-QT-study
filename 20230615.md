# 6월 15일

## BilloardText 
- 1.왼쪽으로 흐르는 텍스트 (빌보드)
- 2.초기 값에서 왼쪽으로 한글자씩 이동하며 흐른다
- 3.왼쪽으로 벗어난 텍스트는 가장 오른쪽에 다시 나옴
- 4.프로그램이 종료될때까지 계속 반복
- ex)
  - hello
  - elloh
  - llohe
  - lohel
  - ohell
  - hello

```python
from PySide2.QtWidgets import *
from PySide2.QtGui import *
from PySide2.QtCore import *

import sys

class Worker(QThread):

    printText = Signal(str)

    def __init__(self, text:str):
        super().__init__()

        self.words = [c for c in text]
        # for c in text:
        #     self.words.append(c)

        self.textLength = len(self.words)
        self.working = True

        # print('self.words: ', self.words)

    def run(self):

        while self.working:

            resultStr = ''.join(self.words)
            # print('result: ', resultStr)

            self.printText.emit(resultStr)

            # 스왑하면서 전체가 한칸씩 이동
            for i in range(0, self.textLength-1):

                next_i = i+1
                val1 = self.words[i]
                val2 = self.words[next_i]

                # 스왑
                self.words[i] = val2
                self.words[next_i] = val1
            
            self.sleep(1)

    def stop(self):
        self.working = False
        self.quit()
        self.wait(5000) #5000ms = 5s

    def pause(self):
        self.working = False
        

class MainWindow(QWidget): 

    def __init__(self, parent=None):
        QWidget.__init__(self, parent)

        self.playing = False

        self.textLabel = QLabel(self)
        self.textLineEdit = QLineEdit(self)

        self.playButton = QPushButton('&Play', self)
        self.playButton.clicked.connect(self.onClickPlayToggle)
        self.stopButton = QPushButton('&Stop', self)
        self.stopButton.clicked.connect(self.onClickStop)

        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(self.playButton)
        buttonLayout.addWidget(self.stopButton)

        layout = QVBoxLayout()
        layout.addWidget(self.textLineEdit)
        layout.addWidget(self.textLabel)
        layout.addLayout(buttonLayout)

        self.setLayout(layout)

    def onClickPlayToggle(self):

        if self.playing:
            self.worker.pause()

        else:
            inputText = self.textLineEdit.text()
            if len(inputText) < 2:
                return

            self.worker = Worker(inputText)
            # self.worker.printText.connect(self.textLabel.setText)
            self.worker.printText.connect(self.onPrintText)
            self.worker.start()

            self.textLineEdit.setEnabled(False)

        self.playing = not self.playing

    def onClickStop(self):
        self.playing = False
        self.worker.stop()
        self.textLineEdit.setEnabled(True)
        self.textLabel.setText('')


    def onPrintText(self, text):
        self.textLabel.setText(text)


if __name__ == '__main__':

    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    app.exec_()
```

> 실행 결과

- play이를 눌러 실행되는 결과
  
![Screenshot from 2023-06-15 11-30-51](https://github.com/ajhwan/OpenCV_study/assets/129160008/220e16e2-594e-40a5-818c-84f3d9cd817d)


- stop을 누르고 멈춘 결과

![Screenshot from 2023-06-15 11-31-03](https://github.com/ajhwan/OpenCV_study/assets/129160008/85574a41-e208-44ac-a8c6-ed7e86d7c37f)


## mouseEvent
```python
import PySide2.QtGui
from PySide2.QtWidgets import *
from PySide2.QtGui import *
from PySide2.QtCore import *
import sys

class MainWindow(QWidget):

    def __init__(self, parent=None):
        QWidget.__init__(self, parent)

        # self.setMouseTracking(True)

        self.rightPress = False

        self.mousePosLocalLabel = QLabel('', self)
        # self.mousePosLocalLabel.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        # self.mousePosLocalLabel.resize(500,200)
        self.mousePosScreenLabel = QLabel('', self)
        # self.mousePosScreenLabel.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        # self.mousePosScreenLabel.resize(500,200)

        layout = QVBoxLayout(self)
        layout.addWidget(self.mousePosLocalLabel)
        layout.addWidget(self.mousePosScreenLabel)

        self.setLayout(layout)

        self.resize(500, 500)

        pass

    # def __str__(self):

    def mousePressEvent(self, event:QMouseEvent):
        # print('mousePressEvent event: ', event)

        # Qt.LeftButton 왼쪽버튼
        # Qt.RightButton 오른쪽버튼
        # event.button()

        if event.button() == Qt.RightButton:
            self.rightPress = True

        return
    
    def mouseReleaseEvent(self, event:QMouseEvent):
        # print('mouseReleaseEvent event: ', event)

        if event.button() == Qt.RightButton:
            self.rightPress = False

        return
    
    def mouseDoubleClickEvent(self, event: QMouseEvent):
        
        return
    
    def mouseMoveEvent(self, event:QMouseEvent):

        if self.rightPress:
            self.mousePosLocalLabel.setText(f'({event.x()}, {event.y()})')
            self.mousePosScreenLabel.setText(f'({event.globalX()}, {event.globalY()})')

        return
    

if __name__ == '__main__':
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    app.exec_()
```
- 오른쪽 버튼을 누르고 움직이면 좌표가 생기고 계속해서 바뀜
 
> 실행 결과

![Screenshot from 2023-06-15 12-31-54](https://github.com/ajhwan/OpenCV_study/assets/129160008/03ebe444-dddf-4db3-9034-f5ab91396741)

## 파이썬에서 아두이노로 시리얼통신
- 파이썬에서 'w' 문자를 보내면 아두이노 LED 켜기
- 파이썬 코드
```python
from PySide2.QtWidgets import *
from PySide2.QtGui import *
from PySide2.QtCore import *
import sys
import serial

class MainWindow(QWidget):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)

        self.inputLineEdit = QLineEdit(self)
        self.sendButton = QPushButton('&Send', self)
        self.sendButton.clicked.connect(self.sendText)

        inputLayout = QHBoxLayout(self)
        inputLayout.addWidget(self.inputLineEdit)
        inputLayout.addWidget(self.sendButton)

        layout = QVBoxLayout(self)
        layout.addLayout(inputLayout)

        self.resize(500, 500)

    def sendText(self):
        
        inputText = self.inputLineEdit.text()
        print('input line: ', inputText)
        # 시리얼 통신 (serial) => 직렬화 ( 데이터를 직성상으로 나열 )
        # Rx(받기)/Tx(보내기) -> Tx/Rx로 교차연결
        # 보드레이트 baudrate
        # TODO: 시리얼 통신을 이용해 문자열을 전송
        ser.write(inputText.encode())
        self.inputLineEdit.setText('')

        pass

PORT = '/dev/ttyUSB0'


def prepare():
    global ser

    #시리얼 포트 연결
    # 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600
    ser = serial.serial_for_url(PORT, baudrate=9600, timeout = 1)

    pass


if __name__ == "__main__":

    prepare()
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    app.exec_()
```

- 아두이노 코드
```cpp
void setup() {
  Serial.begin(9600);
  pinMode(13, OUTPUT);
}

void loop() {
  //digitalWrite(13, LOW);
  
  if (Serial.available() > 0){
    char c = Serial.read();

    if (c == 'w'){
      digitalWrite(13, HIGH);
      delay(500);
      digitalWrite(13, LOW);
      delay(500);
    }
  }
  delay(100);
}
```
- 실행 결과 : 'w' 신호를 보내면 LED가 들어왔다가 꺼지게 됨

## 파이썬 window 창으로 신호받기

- 파이썬 코드
```python
from PySide2.QtWidgets import *
from PySide2.QtCore import *
from PySide2.QtGui import *

import sys

# pip install pyserial
import serial


class Worker(QThread):

    readText = Signal(str)

    def run(self):

        while True:
            if ser.readable():
                result = ser.readline()
                result = result.decode()
                result = result.replace('\r\n', '')
                # print(result, end='')
                # print(result)

                self.readText.emit(result)
                self.msleep(300)


class MainWindow(QWidget):
    def __init__(self, parent=None):
        QWidget.__init__(self, parent)

        self.inputLineEdit = QLineEdit(self)
        self.sendButton = QPushButton('&Send', self)
        self.sendButton.clicked.connect(self.sendText)

        inputLayout = QHBoxLayout()
        inputLayout.addWidget(self.inputLineEdit)
        inputLayout.addWidget(self.sendButton)

        self.textEdit = QTextEdit(self)
        self.textEdit.setReadOnly(True)

        layout = QVBoxLayout(self)
        layout.addLayout(inputLayout)
        layout.addWidget(self.textEdit)

        self.worker = Worker()
        self.worker.start()
        self.worker.readText.connect(self.printText)

        self.resize(500,500)

    def printText(self, read):
        self.textEdit.setText(self.textEdit.toPlainText() + read)
        pass


    def sendText(self):

        inputText = self.inputLineEdit.text()
        print('inputText:', inputText)

        # 시리얼통신 (serial) => 직렬화 (데이터를 직선상으로 나열)
        # Rx/Tx (받기/보내기) -> Tx/Rx
        # 보드레이트 baudrate
        # 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
        # TODO 시리얼통신을 이용해 문자열을 전송
        ser.write(inputText.encode())

        self.inputLineEdit.setText('')

        pass

PORT = '/dev/ttyUSB0'
def prepare():

    global ser

    # 시리얼 포트 연결
    # 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    ser = serial.serial_for_url(PORT, baudrate=9600, timeout=1)
    pass

if __name__ == '__main__':

    prepare()
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    app.exec_()

    window.worker.quit()
    ser.close()
```
- 아두이노 코드

```cpp
void setup() {
  Serial.begin(9600);

}

void loop() {
  Serial.println("a");
  delay(1000);
  // put your main code here, to run repeatedly:

}
```

> 실행 결과

- 아두이노 시리얼 창

![Screenshot from 2023-06-15 16-07-08](https://github.com/ajhwan/OpenCV_study/assets/129160008/cbbb03c7-14ac-48c5-8cc3-714c4b7b0ec1)

- 파이썬 window 창

![Screenshot from 2023-06-15 16-05-01](https://github.com/ajhwan/OpenCV_study/assets/129160008/17e4f4ba-40f5-4e50-b3f3-11e13b036e38)


